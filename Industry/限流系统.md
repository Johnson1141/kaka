## 限流系统

### FAQ
1. 引用中第一篇博客说分布式系统不能在单节点使用限流算法，而是需要一个全局的redis？如果每个节点都限制了自己的QPS，集群的节点数是一定的，集群的QPS就可以限制了呀？
>最快的方式是使用 RateLimit 类，但是这仅限制在单节点，如果是分布式系统，每个节点的 QPS 是一样的，请求量到服务接口那的话就是 QPS * 节点数 了。所以这种方案在分布式的情况下不适用！
1. 为啥令牌桶算法重复时间间隔精度会不够，usleep(1)不行？
1. 改成触发式添加令牌不就退化成限制QPS的方法吗，为啥不会导致单个时间窗口内令牌不均匀？

### Theory
1. 限制并发：“请求队列+工作线程池”架构中工作线程池中的活跃线程数就是并发。
2. 限制QPS：使用一个全局变量表示令牌数量，工作线程对这个变量递增，如果超限就拒绝，通过一个后台线程每秒清零这个变量。（译者注：**这种方法相当于令牌桶算法中r和b相等，优点是简单，缺点是后台线程清零全局变量不是匀速的向桶里面放入令牌，虽然确实限制了QPS，但是1秒内的流量分布可能不均匀，导致工作线程数瞬间打满造成机器资源争夺**。）
3. 令牌桶
    1. 算法描述：
        1. 假如用户配置的平均发送速率为r，则每隔1/r秒一个令牌被加入到桶中
        2. 假设桶中最多可以存放b个令牌。如果令牌到达时令牌桶已经满了，那么这个令牌会被丢弃
        3. 当流量以速率v进入，以相同的速率从桶中令牌，拿到令牌的流量正常处理，拿不到令牌流量执行熔断
    1. 算法分析：
        1. r：长期来看流量实际处理的速率，拒绝的流量为(v-r)
        2. b：应对流量突增

### Practice
#### Guava::RateLimiter
Guava工程包含了若干被Google的Java项目广泛依赖 的核心库，例如：集合（collections）、缓存（caching）、原生类型支持（primitives support）、并发库（concurrency libraries）、通用注解（common annotations）、字符串处理（string processing）、I/O 等等。 所有这些工具每天都在被Google的工程师应用在产品服务中。

[RateLimiter](https://github.com/google/guava/blob/master/android/guava/src/com/google/common/util/concurrent/RateLimiter.java)是Guava的Java版本的令牌桶算法。

原始令牌桶算法存在的后台线程重复的间隔精度不够精确的问题：后台线程需要每1/r秒向桶里添加一个令牌，r>1000时线程执行的时间间隔根本没办法设置。所以Guava采用了请求触发添加令牌：取令牌之前先添加令牌，添加令牌的数量=max(b,(当前时间-上一次添加令牌的时间)/r)

#### github.com/juju/ratelimit
github上star比较多（600+）的golang版本令牌桶算法

#### github.com/wukq/rate-limiter
用于redis的lua实现的触发式令牌桶算法

### Reference
1. [基于分布式环境下限流系统的设计](https://zhuanlan.zhihu.com/p/31484931?comefrom=http://blogread.cn/news/)
2. [基于Redis的限流系统的设计](https://mp.weixin.qq.com/s/ewjGZCgc_TUhiZIINCLfbg)
3. [github.com/google/guava](https://github.com/google/guava)
4. [github.com/juju/ratelimit](https://github.com/juju/ratelimit)
4. [github.com/wukq/rate-limiter](https://github.com/wukq/rate-limiter)