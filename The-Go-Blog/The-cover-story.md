## [The cover story](https://blog.golang.org/cover)

2 December 2013 By Rob Pike

### 简介
在Go语言这个项目设计的初期就考虑了工具化，具体的工具包括：文档展现工具[godoc](http://golang.org/cmd/godoc)、代码格式化工具[gofmt](http://golang.org/cmd/gofmt)、API接口重写工具[gofix](http://golang.org/cmd/fix)，这些工具都是Go语言的特性的代表。最重要的工具是[go](http://golang.org/cmd/go)，它集成了Go程序的自动安装、构建、测试，除了需要把源码作为编译参数就能使用。
>Those tools include some of the most iconic pieces of Go technology such as the documentation presentation tool godoc, ...

Go 1.2版本发布包含了一个新的工具，用于测试覆盖率。这个工具使用了一个不同寻常的方法产生覆盖率统计结果，这个方法是建立在godoc以及其他工具提供的技术能力之上。
>..., an approach that builds on the technology laid down by godoc and friends.

### 工具化支持
先介绍一些背景知识：[支持工具化对于编程语言意味着什么？](http://talks.golang.org/2012/splash.article#TOC_17.)。它意味着使用编程语言本身的特性可以很容易编写功能强大的工具，并且语言的生态圈可以支持构建各种类型的工具。

Go语言有很多特性支持工具化。对于初学者，Go语言的语法很容易解析，Go语言的语法设计的目标就是能够不使用复杂的机器就可以分析出来。
>The grammar aims to be free of special cases that require complex machinery to analyze.

Go语言尽可能的通过词汇和句法结构使得代码的语法特性容易理解，例如：使用大写字母开头的标识符作为导出的名字，另外相比C等传统语言，Go从根本上简化了作用域规则。
>Examples include the use of upper-case letters to define exported names and the radically simplified scoping rules compared to other languages in the C tradition.

最后，标准库提供了生产环境质量的包用于Go源码的分析，更令你难以想象的是，标准库还提供了一个生产环境质量的包用于优雅打印Go的语法树。
>Finally, the standard library comes with production-quality packages to lex and parse Go source code. They also include, more unusually, a production-quality package to pretty-print Go syntax trees.

这些包合起来组成了gofmt工具的核心部分。值得单独说明的是优雅打印，它可以根据任意的Go语法树输出Go语言标准格式化的、人类可阅读的、正确的代码，优雅打印使得构建将Go源码树转换为正确且易于阅读的代码这类工具成为可能。

这类工具中的一个例子是gofix，它可以自动改写代码，用于升级新的语言特性或者升级标准库接口。它让我们[在Go 1.0之前的迭代中](http://blog.golang.org/the-path-to-go-1)能够大胆的修改Go语言的基础特性和标准库，用户只需要执行一下这个工具就可以自动修改用户代码适配最新的Go版本。

在Google内部，我们使用gofix工具在一个巨大的代码库进行彻底的修改，这在其他任何我们使用的语言中都是不可想象的。因为这个工具的存在，我们不再需要支持多种版本的API，使用gofix就可以通过一个操作升级整个公司的代码。

这些包并除了这些工具以外还可以有更多的应用，例如：它们可以用于很容易的实现诸如IDE插件之类的小程序。包、工具、插件这些东西联合起来，通过自动化使得Go语言的生态环境更具生产力。
>They also make it easy to write more modest programs such as IDE plugins, for instance.

### 测试覆盖率
测试覆盖率用于描述一个包的代码在执行单测时有多少被运行过。如果执行单测时这个包80%的代码语句都被运行了，那么我们就说覆盖率是80%。

Go 1.2中提供覆盖率测试的程序是对Go语言生态环境工具化支持的最新探索。

常规的计算覆盖率的方法是对二进制程序埋点。例如：GNU的[gcov](http://gcc.gnu.org/onlinedocs/gcc/Gcov.html)程序会在每个分支的地方设置一个断点，当某个分支被运行到以后，断点被清除并将这个分支的语句标记为“覆盖”。

这个方法是可行的并且被广泛使用。Go早期的覆盖率测试工具甚至采用了一模一样的方法。但是这个方法的问题是实现起来很困难，因为分析二进制程序的执行是分困难的，另外还需要一个可靠的方法把二进制的执行过程映射到源码上，这也很难做到，任何使用过源码级调试器的用户都可以证明。调试信息不准确、内联函数问题都会导致测试覆盖率的分析变得很复杂。更重要的是这种方法是不可移植的，对于不同的CPU架构需要分别实现，并且在一定程度上每种操作系统需要单独实现，因为不同系统对于调试的支持也不同。

然而，如果你使用的是gccgo，那么这个方法是可以工作的，gcov工具可以输出覆盖率信息。但是如果你使用的是更常用的Go编译工具链gc，在Go 1.2版本之前，你都是不幸的。

### Go语言的测试覆盖率
Go语言的新测试覆盖率的工具使用率新的方法避免动态调试。这个方法的思路很简单：编译前修改包的源码，添加埋点的代码，编译运行修改后的代码，然后输出统计信息。因为go命令控制了从源码到执行测试的完整过程，所以修改源码进行埋点很容易实现。

下面是一个例子，假如我们有一个简单的单文件包如下：
```golang
package size

func Size(a int) string {
    switch {
    case a < 0:
        return "negative"
    case a == 0:
        return "zero"
    case a < 10:
        return "small"
    case a < 100:
        return "big"
    case a < 1000:
        return "huge"
    }
    return "enormous"
}
```

添加测试代码：
```golang
package size

import "testing"

type Test struct {
    in  int
    out string
}

var tests = []Test{
    {-1, "negative"},
    {5, "small"},
}

func TestSize(t *testing.T) {
    for i, test := range tests {
        size := Size(test.in)
        if size != test.out {
            t.Errorf("#%d: Size(%d)=%s; want %s", i, test.in, size, test.out)
        }
    }
}
```

我们在运行`go test`时增加`-cover`参数来开启覆盖率统计功能，获取包的覆盖率。
```
% go test -cover
PASS
coverage: 42.9% of statements
ok      size    0.026s
%
```

注意到覆盖率是42.9%，这个数值不怎么高，在我们考虑提升这个值之前，我们先看下它是如何计算出来的。

当开启了覆盖率测试功能时，`go test`运行cover工具，它是Go语言发布版里面独立的程序，修改待测试的代码然后编译就是这个程序完成的。修改以后的`Size`函数如下：
```golang
func Size(a int) string {
    GoCover.Count[0] = 1
    switch {
    case a < 0:
        GoCover.Count[2] = 1
        return "negative"
    case a == 0:
        GoCover.Count[3] = 1
        return "zero"
    case a < 10:
        GoCover.Count[4] = 1
        return "small"
    case a < 100:
        GoCover.Count[5] = 1
        return "big"
    case a < 1000:
        GoCover.Count[6] = 1
        return "huge"
    }
    GoCover.Count[1] = 1
    return "enormous"
}
```

程序的每个执行片段都标记了一个赋值语句，当执行到对应的片段时，会被标记为这个片段被执行。cover工具还会生成一个只读的数据结构，通过它可以知道某个计数器对应源代码的哪个位置。当测试执行完成时，计数器被收集起来，通过统计有多少计数器被标记就可以计算出覆盖率的百分比。
>The counter is tied to the original source position of the statements it counts through a second read-only data structure that is also generated by the cover tool.

尽管标记赋值可能看起来有些开销，但是在编译时会把它们实现为一条mov指令，这样运行时的开销就小很多，经验数据是执行一个典型的测试开销增加3%。因为开销很小，所以可以把覆盖率测试作为标准开发流水线的一部分。

### 查看结果
我们的例子覆盖率的结果很不理想，如果想定位原因，我们让`go test`输出一个覆盖率profile文件，它包括了收集的统计信息，我们可以根据其中的信息进一步研究。实现很简单：用`-coverprofile`选项执行一个输出文件，这个选项会自动设置`-cover`选项，开启覆盖率分析功能。
```
% go test -coverprofile=coverage.out 
PASS
coverage: 42.9% of statements
ok      size    0.030s
%
```

测试和之前执行的过程是一样的，只是把结果输出到一个文件中，如果想研究这个文件，我们不再用`go test`命令，而是使用测试覆盖率工具cover。首先，我们可以按照函数粒度统计输出覆盖率（因为我们的例子中只有一个函数，所以按照函数统计覆盖率和总的覆盖率是相同的，得不到覆盖率低的原因）：
```
% go tool cover -func=coverage.out
size.go:    Size          42.9%
total:      (statements)  42.9%
%
```

一种更有趣的方法查看覆盖率结果是通过HTML文件展现的源码，其中装饰了覆盖率信息，通过`-html`选项可以调用这种展现方式：
```
$ go tool cover -html=coverage.out
```

当执行上面的命令时，会弹出一个浏览器窗口，绿色的表示覆盖的代码，红色表示未覆盖，灰色的表示没有被埋点，下面是一个截图：

![](The-cover-story/1.png)

通过这个图，覆盖率低的原因就一目了然：我们忽略了一些测试case。通过颜色我们可以明确的看出来是哪些，这样我们就很容易提升覆盖率。

### 热图
源码层面统计测试覆盖率的最大的优点是容易对代码以不同的方式埋点。例如，我们不仅可以获取某个语句是不是被执行了，而且还能知道它被执行了多少次。

`go test`命令接收一个`-covermode`参数用于选择三种覆盖率的模式之一：

* set：是否这个语句被执行过
* count：每条语句执行了多少次
* atomic：和count类似，但是对于并行程序可以准确计数

默认值是`set`，我们前面已经看到了。`atomic`选项用于在执行并行算法时需要准确计数。它通过[sync/atomic包](http://golang.org/pkg/sync/atomic/)中的原子操作进行计数，这个操作开销很大。`count`方式能够覆盖大多数的场景，并且开销很小。

让我们用标准库的fmt包演示一下`count`功能，我们运行测试然后把覆盖率profile文件输出，便于我们后面更友好的查看覆盖率信息。
```
% go test -covermode=count -coverprofile=count.out fmt 
ok      fmt    0.056s    coverage: 91.7% of statements
%
```

覆盖率的结果比我们前面的例子好很多（覆盖率和覆盖率的模式无关），我们输出函数粒度的覆盖率结果：
```
% go tool cover -func=count.out
fmt/format.go: init              100.0%
fmt/format.go: clearflags        100.0%
fmt/format.go: init              100.0%
fmt/format.go: computePadding     84.6%
fmt/format.go: writePadding      100.0%
fmt/format.go: pad               100.0%
...
fmt/scan.go:   advance            96.2%
fmt/scan.go:   doScanf            96.8%
total:         (statements)       91.7%
```

HTML输出的结果能带来很大的收益：
```
% go tool cover -html=count.out
```

下图是`pad`函数的展现结果：注意绿色的程度的变化。亮绿色表示执行计数更高，暗绿色表示计数更低。当你把鼠标悬停在语句上时，可以弹出具体执行的次数。覆盖率profile文件在生成时，语句的计数是下面这样的（我们把计数值放在了行首便于显示）。通过计数值可以看到函数执行的很多信息，在调优时这些信息很有用。

>At the time of writing, the counts come out like this (we've moved the counts from the tool tips to beginning-of-line markers to make them easier to show):

![](The-cover-story/2.png)

```
2933    if !f.widPresent || f.wid == 0 {
2985        f.buf.Write(b)
2985        return
2985    }
  56    padding, left, right := f.computePadding(len(b))
  56    if left > 0 {
  37        f.writePadding(left, padding)
  37    }
  56    f.buf.Write(b)
  56    if right > 0 {
  13        f.writePadding(right, padding)
  13    }
```

### Basic blocks
你可能注意到前面例子中的闭括号行的计数值和你预期的值不一致。这是因为测试覆盖率是一个不准确的科学。

然而，这里发生的事情值得解释一下。我们希望覆盖率标记能够按照分支来划分界限，就像传统方法中对二进制埋点的方式。但通过重写源码的方法统计覆盖率则很难做到这一点，因为在源码中分支并不是明显出现的。

覆盖率标记的是“埋点块”，典型的埋点块是用大括号括起来的代码段。准确的区分埋点块是很困难的，Go目前使用的算法是把闭括号计算在埋点块内，然而开括号则计算在埋点块外面。更有意思的是这个表达式：`f() && g()`，我们没有对`f`和`g`分别埋点，尽管它们运行的次数和`f`运行的次数是相同的。

公平的说，gcov也有这个问题，它对于分支的埋点是正确的，但是展现时却显示的是行号，二者会有些细微差别。

>You might have noticed that the counts in the previous example were not what you expected on the lines with closing braces. That's because, as always, test coverage is an inexact science.

>What's going on here is worth explaining, though. We'd like the coverage annotations to be demarcated by branches in the program, the way they are when the binary is instrumented in the traditional method. It's hard to do that by rewriting the source, though, since the branches don't appear explicitly in the source.

>What the coverage annotation does is instrument blocks, which are typically bounded by brace brackets. Getting this right in general is very hard. A consequence of the algorithm used is that the closing brace looks like it belongs to the block it closes, while the opening brace looks like it belongs outside the block. A more interesting consequence is that in an expression like

>`f() && g()`

>there is no attempt to separately instrument the calls to f and g, Regardless of the facts it will always look like they both ran the same number of times, the number of times f ran.
To be fair, even gcov has trouble here. That tool gets the instrumentation right but the presentation is line-based and can therefore miss some nuances.

### The big picture
上面就是Go 1.2中的测试覆盖率的故事。这个新工具以及它的有趣的实现不仅统计了测试覆盖率，而且覆盖率的表现方式很容易理解，甚至提供了提取详细信息的功能。

测试是软件开发中很重要的一个部分，测试覆盖率是向测试策略中添加规则的最简单的一种。向前，测试，覆盖。
>Testing is an important part of software development and test coverage a simple way to add discipline to your testing strategy. Go forth, test, and cover.


