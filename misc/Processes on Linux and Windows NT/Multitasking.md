# [多任务](http://www.tldp.org/LDP/LG/issue23/flower/multitask.html)

当一个进程启动以后，在它执行过程中只有它占用全部的处理器是效率很低的，因为大多数进程会很频繁的中断运行以等待输入，例如：设备I/O、键盘输入或者磁盘访问，因此这样会导致大量的CPU时间浪费在阻塞等待中，于是为了执行一系列的独立任务需要花费的时间很长。CPU必须处理异步的软件和硬件中断，它们需要在一个短时间内高优先级的服务，因此当前运行在CPU上的进程就要被取代，直到处理完中断以后才能继续。这种中断可能由输入缓冲满事件触发，如果不及时处理会导致不可恢复的数据丢失。

现代操作系统为了增加吞吐效率实现了一种能够允许很多进程同时运行的方法。多个进程交叉的使用处理器，因为现代处理器的速度相比I/O设备要快得多，使得在许多进程同时运行的系统中，某个特定的进程都能伪实时响应用户的请求成为可能。因为浪费在等待外部输入的时间减少，所以完成许多任务的总时间因此下降。

这个机制叫做多任务或多程序，操作系统中的调度服务来控制进程执行的顺序。一些操作系统（例如Windows 3.1）依赖于进程自己在固定的时间间隔结束时或者等待I/O时让出CPU。这个方法叫做协作式多任务（co-operative multitasking），它有很多的问题，例如：如果一个进程没能按照预期的时间释放CPU就会导致故障，此时所有其他的进程会被阻塞，操作系统没法获得CPU的控制权，最终导致系统死锁或者崩溃。

一个更好的方法是抢占是多任务（pre-emptive multitasking），这种方法也在大多数现代操作系统中被使用以提高多任务的效率。它由操作系统决定哪个进程获取CPU的使用权，操作系统可以给进程分配CPU时间、也可以从一个进程剥夺CPU。每个候选的进程根据它们的优先级获得一个CPU时间片（quantum），their process class and also their voluntary release of the processor as they wait for external input.